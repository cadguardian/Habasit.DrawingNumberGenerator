@using System.Text.RegularExpressions
@using System.IO
@using System.Text.Json
@using System.Text.Json.Serialization
@inject HttpClient Http
@inject IJSRuntime JS
@inject IDrawingNumber drawingNumber

<div class="container-fluid no-print">
    <div class="card p-3 shadow-sm">
        <!-- Header Section with Summary Information -->
        <div class="d-flex justify-content-between align-items-center card-header mb-3">
            <div class="fw-bold">Drawing Manager</div>
        </div>

        <div class="card-body">
            @if (reportHeader != null)
            {
                <small class="text-muted">
                    <span>Files: @reportHeader.TotalFiles</span> |
                    <span>Categories: @reportHeader.TotalCategories</span> |
                    <span>Total Size: @reportHeader.TotalSizeMb MB</span> |
                    <span>Date: @reportHeader.GeneratedDate.ToString("yyyy-MM-dd")</span>
                </small>
            }
        </div>

        <!-- Filter and Search Section -->
        <div class="d-flex mb-3">
            <div class="input-group me-2 flex-grow-1">
                <input type="text" class="form-control" placeholder="Search for CAD files..." @bind="searchQuery" @bind:event="oninput" @onkeypress="HandleKeyPress" />
                @if (isSearchMode)
                {
                    <button class="btn btn-outline-secondary" @onclick="ClearSearch">Clear</button>
                }
            </div>
            
        </div>
        <div class="text-center mb-4">
        <div class="btn-group" role="group">
            <button class="btn btn-sm btn-dark" @onclick="ApplyFilters">Apply Filters</button>
            <button class="btn btn-sm btn-primary" @onclick="OnSearch">Search Drawings</button>
        </div>
    </div>


        <div class="alert alert-info p-2" style="font-size: 0.8rem;">
            Use <strong>*</strong> as a wildcard: <strong>*term</strong> to find items ending with "term", <strong>term*</strong> for items starting with "term", or <strong>term*term</strong> for partial matches.
        </div>


        <!-- Search Results List -->
        @if (isSearchMode)
        {
            @if (searchResults.Any())
            {
                <ul class="list-group list-group-flush">
                    @foreach (var file in searchResults)
                    {
                        <li class="list-group-item d-flex align-items-center">
                            <span class="me-2">@GetFileIcon(file.FileType)</span>
                            <div class="flex-grow-1">
                                <h6 class="mb-1">@file.DisplayName</h6>
                                <small class="text-muted">File Path: @file.RelativePath</small>
                            </div>
                            <button class="btn btn-outline-primary btn-sm"
                                    @onclick="() => CopyDrawingFilePathToClipboard(file.RelativePath)"
                                    data-bs-toggle="tooltip"
                                    title="Copy to clipboard">
                                <i class="bi bi-clipboard"></i> Copy
                            </button>
                        </li>
                    }
                </ul>
            }
            else
            {
                <!-- No Search Results -->
                <div class="alert alert-info text-center">No results found for "<strong>@searchQuery</strong>". try ending with an <strong>*. For example: *@searchQuery*</strong></div>
            }
        }
    </div>

</div>

@code {
    private ReportHeader? reportHeader;
    private bool dataLoaded = false;
    private JsonDocument? jsonDoc;
    private string searchQuery = string.Empty;
    private string universalSearch = string.Empty;
    private bool isSearchMode = false;
    private List<FileItemDisplay> searchResults = new();
    private List<FileItem> allFiles = new();

    protected override async Task OnInitializedAsync()
    {
        await LoadData();
    }

    private void HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            OnSearch();
        }
    }

    // Load JSON data
    private async Task LoadData()
    {
        try
        {
            var stream = await Http.GetStreamAsync("data/pdf_drawings.json");
            jsonDoc = await JsonDocument.ParseAsync(stream);

            if (jsonDoc.RootElement.TryGetProperty("header", out JsonElement headerElement))
            {
                reportHeader = JsonSerializer.Deserialize<ReportHeader>(headerElement.GetRawText());
            }

            if (jsonDoc.RootElement.TryGetProperty("directory_structure", out JsonElement directoryStructure))
            {
                ExtractFiles(directoryStructure, "", allFiles);
            }

            dataLoaded = true;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error parsing JSON: {ex.Message}");
        }
    }

    void ExtractFiles(JsonElement directory, string currentCategory, List<FileItem> files)
    {
        foreach (var property in directory.EnumerateObject())
        {
            if (property.Name.Equals("files", StringComparison.OrdinalIgnoreCase))
            {
                foreach (var file in property.Value.EnumerateArray())
                {
                    var fullpath = @"K:\Operations\Modular\Special Builds\Belts\" + file.GetProperty("relative_path").GetString();

                    files.Add(new FileItem
                        {
                            Filename = file.GetProperty("filename").GetString() ?? string.Empty,
                            RelativePath = fullpath ?? string.Empty,
                            SizeMb = file.GetProperty("size_mb").GetDouble(),
                            CreatedDate = file.GetProperty("created_date").GetDateTime(),
                            FileType = file.GetProperty("filename").GetString()?.EndsWith(".pdf") == true ? "PDF" : "DWG"
                        });
                }
            }
            else
            {
                ExtractFiles(property.Value, property.Name, files);
            }
        }
    }

    private void ApplyFilters()
    {
        UpdateSearchWithFilters();
        searchQuery = universalSearch;
    }

    private void OnSearch()
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
        {
            isSearchMode = false;
            searchResults.Clear();
            return;
        }

        List<FileItemDisplay> matchedResults;

        if (searchQuery.Contains("*"))
        {
            var regexPattern = "^" + Regex.Escape(searchQuery).Replace("\\*", ".*") + "$";
            var regex = new Regex(regexPattern, RegexOptions.IgnoreCase);

            matchedResults = allFiles
                .Where(f => regex.IsMatch(f.Filename))
                .Select(f => new FileItemDisplay
                    {
                        Filename = f.Filename,
                        DisplayName = GetHumanReadableName(f.Filename),
                        RelativePath = f.RelativePath,
                        FileType = f.FileType
                    })
                .ToList();
        }
        else
        {
            var query = searchQuery.ToLower();
            matchedResults = allFiles
                .Where(f => f.Filename.ToLower().Contains(query))
                .Select(f => new FileItemDisplay
                    {
                        Filename = f.Filename,
                        DisplayName = GetHumanReadableName(f.Filename),
                        RelativePath = f.RelativePath,
                        FileType = f.FileType
                    })
                .ToList();
        }

        searchResults = matchedResults;
        isSearchMode = true;
    }

    private void UpdateSearchWithFilters()
    {
        var filters = new List<string>();

        if (!string.IsNullOrWhiteSpace(drawingNumber.QueryString))
        {
            filters.Add(drawingNumber.QueryString);
        }

        universalSearch = string.Join("", filters);
    }

    private void ClearSearch()
    {
        searchQuery = string.Empty;
        universalSearch = string.Empty;
        isSearchMode = false;
        searchResults.Clear();
    }

    private async Task CopyDrawingFilePathToClipboard(string drawingNumber)
    {
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", drawingNumber);
        await JS.InvokeVoidAsync("showToast", drawingNumber);
    }

    string GetHumanReadableName(string filename)
    {
        var nameWithoutExtension = Path.GetFileNameWithoutExtension(filename);
        return nameWithoutExtension;
    }

    private MarkupString GetFileIcon(string fileType)
    {
        return fileType switch
        {
            "PDF" => (MarkupString)"<i class='fas fa-file-pdf text-danger'></i>",
            "DWG" => (MarkupString)"<i class='fas fa-drafting-compass text-primary'></i>",
            _ => (MarkupString)"<i class='fas fa-file text-muted'></i>"
        };
    }

    public class ReportHeader
    {
        [JsonPropertyName("pdf_drawings")]
        public int TotalFiles { get; set; }
        [JsonPropertyName("total_categories")]
        public int TotalCategories { get; set; }
        [JsonPropertyName("total_size_mb")]
        public double TotalSizeMb { get; set; }
        [JsonPropertyName("generated_date")]
        public DateTime GeneratedDate { get; set; }
    }

    public class FileItem
    {
        public string Filename { get; set; } = string.Empty;
        public string RelativePath { get; set; } = string.Empty;
        public double SizeMb { get; set; }
        public DateTime CreatedDate { get; set; }
        public string FileType { get; set; } = string.Empty;
    }

    private class FileItemDisplay
    {
        public string Filename { get; set; } = string.Empty;
        public string DisplayName { get; set; } = string.Empty;
        public string RelativePath { get; set; } = string.Empty;
        public string FileType { get; set; } = string.Empty;
    }
}
